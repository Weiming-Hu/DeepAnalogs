# "`-''-/").___..--''"`-._
#  (`6_ 6  )   `-.  (     ).`-.__.`)   WE ARE ...
#  (_Y_.)'  ._   )  `._ `. ``-..-'    PENN STATE!
#    _ ..`--'_..-_/  /--'_.' ,'
#  (il),-''  (li),'  ((!.-'
#
# Author: Weiming Hu <weiming@psu.edu>
#         Geoinformatics and Earth Observation Laboratory (http://geolab.psu.edu)
#         Department of Geography and Institute for CyberScience
#         The Pennsylvania State University
#
# This file defines a customized dictionary for AnEn.
#

import os
import gc
import netCDF4
import numpy as np

from netCDF4 import Dataset
from datetime import datetime, timedelta, timezone
from DeepAnalogs.utils import summary, binary_search


class AnEnDict(dict):
    """
    This is a wrapper class around Python dictionary designed specifically for AnEn tasks
    """

    def __init__(self, file_path, file_type, verbose=False, reverse_data_dimensions=True, stations_index=None):
        """
        Reads a specific type of NetCDF file. Currently, the type can either be 'Forecasts' or 'Observations'.
        More information about specific type and corresponding variables can be found
        [here](https://weiming-hu.github.io/AnalogsEnsemble/2019/01/16/NetCDF-File-Types.html)

        :param file_path: an NetCDF file path
        :param file_type: 'Forecasts' or 'Observations'
        :param verbose: whether to print progress information
        :param reverse_data_dimensions: If your NetCDF file is generated by R, the dimensions are likely to be flipped
        when reading into Python. Set this to True to flip the dimensions back to pass assertion tests.

        :return: An AnEn dictionary
        """
        super().__init__()
        
        if not stations_index is None:
            assert isinstance(stations_index, list)

        if file_type == 'Forecasts':
            variables = ['ParameterNames', 'ParameterCirculars', 'Xs', 'Ys', 'Times', 'FLTs', 'Data']
        elif file_type == 'Observations':
            variables = ['ParameterNames', 'Xs', 'Ys', 'Times', 'Data']
        else:
            raise Exception('File type, {}, is not recognized'.format(file_type))

        self._tag = file_type

        # Open the NetCDF file
        nc = Dataset(os.path.expanduser(file_path))

        # Set default netCDF4 Dataset behaviors
        nc.set_auto_chartostring(True)
        nc.set_auto_mask(False)

        # Check whether all names exist in the file
        if not all([variable in nc.variables.keys() for variable in variables]):
            raise Exception('The input file is missing some variables for the specified file type. Please check doc.')

        # Read each variable
        for variable in variables:
            if verbose:
                print('Reading {} ...'.format(variable))
            
            if stations_index is None:
                self[variable] = nc.variables[variable][:]
            else:
                if variable in ('Xs', 'Ys'):
                    self[variable] = nc.variables[variable][stations_index]
                elif variable == 'Data':
                    if self._tag == 'Forecasts':
                        self[variable] = nc.variables[variable][:, :, stations_index]
                    else:
                        self[variable] = nc.variables[variable][:, stations_index]
                else:
                    self[variable] = nc.variables[variable][:]
              

        # Close the file connection
        nc.close()

        # Data type conversion. See more below:
        #
        # Convert to list: Xs, Ys
        # Convert to timedelta list: FLTs
        # Convert to UTC datetime list: Times
        # Convert to string list: ParameterNames, ParameterCirculars
        #
        for variable in ['Xs', 'Ys']:
            if variable in self.keys():
                if verbose:
                    print('Converting {} to a list ...'.format(variable))

                self[variable] = self[variable].tolist()

        if 'FLTs' in self.keys():
            if verbose:
                print('Converting FLTs to a timedelta list ...')

            self['FLTs'] = [timedelta(seconds=delta) for delta in self['FLTs'].tolist()]

        if verbose:
            print('Converting Times to a datetime list ...')

        self['Times'] = [datetime.fromtimestamp(posix, timezone.utc) for posix in self['Times'].tolist()]

        for variable in ['ParameterNames', 'ParameterCirculars']:
            if variable in self.keys():
                if verbose:
                    print('Converting {} to a string list ...'.format(variable))
                
                if len(self[variable].shape) > 1:
                    self[variable] = netCDF4.chartostring(self[variable])
                
                self[variable] = self[variable].tolist()

                # Remove empty strings
                self[variable] = [s for s in self[variable] if s]

        # Flip dimensions of the member Data if needed
        if reverse_data_dimensions:
            if verbose:
                print('Reversing the dimensions of Data ...')

            self['Data'] = np.transpose(self['Data'])

        # Check dimensions
        if verbose:
            print('Checking data integrity ...')
        
        assert len(self['Ys']) == len(self['Xs']), 'X and Y coordinates should have the same length!'
        assert self['Data'].shape[0] == len(self['ParameterNames']), 'Data must have the same parameter count!'
        assert self['Data'].shape[1] == len(self['Xs']), 'Data must have the same coordinate count!'
        assert self['Data'].shape[2] == len(self['Times']), 'Data must have the same time count!'

        if file_type == 'Forecasts':
            assert len(self['ParameterCirculars']) <= len(self['ParameterNames']), "Too many circular variables!"
            assert self['Data'].shape[3] == len(self['FLTs']), 'Data must have the same lead time count!'

        if verbose:
            print('Reading {} is complete!'.format(file_type))

    #################
    # Class Methods #
    #################

    def subset_stations(self, keep):

        # Sanity check
        assert isinstance(keep, list) and len(keep) > 0, 'Keep should be a non-empty list!'

        self['Xs'] = [self['Xs'][i] for i in keep]
        self['Ys'] = [self['Ys'][i] for i in keep]

        if self._tag == 'Observations':
            self['Data'] = self['Data'][:, keep, :]
        elif self._tag == 'Forecasts':
            self['Data'] = self['Data'][:, keep, :, :]
        else:
            raise Exception('Unknown tag {}. This is fatal!'.format(self._tag))

        # Garbage collection
        gc.collect()

    def subset_variables(self, keep):

        # Sanity check
        assert isinstance(keep, list) and len(keep) > 0, 'Keep should be a non-empty list!'

        if isinstance(keep[0], str):

            # If names are provided, translate names to indices
            for index, name in enumerate(keep):
                keep[index] = self['ParameterNames'].index(name)

        elif isinstance(keep[0], int):
            # Indices are provided. Nothing should be done
            pass

        else:
            raise Exception('Keep must contain either names or integer indices!')

        # Subset Data
        self['Data'] = self['Data'][keep]

        # Subset ParameterNames
        self['ParameterNames'] = [self['ParameterNames'][index] for index in keep]

        # Subset ParameterCirculars
        if 'ParameterCirculars' in self:
            self['ParameterCirculars'] = [name for name in self['ParameterCirculars'] if name in self['ParameterNames']]

        # Garbage collection
        gc.collect()

    def remove_times_index(self, times_index):

        # Sanity check
        assert len(times_index) == len(set(times_index)), 'The indices to remove must not have duplicates!'

        # Remove specified times
        self['Data'] = np.delete(self['Data'], times_index, axis=2)

        for index in sorted(times_index, reverse=True):
            del self['Times'][index]

    def align_observations(self, aligned_times, aligned_lead_times):

        # Sanity check: This function only works for Observations.
        if self._tag != 'Observations':
            raise Exception('The function align_observations only works for observations. Check the dictionary tag!')

        # Type checks
        assert isinstance(aligned_times, list), 'Argument aligned_times should be a list!'
        assert isinstance(aligned_lead_times, list), 'Argument aligned_lead_times should be a list!'
        assert len(aligned_times) > 0, 'Argument aligned_times must not be empty!'
        assert len(aligned_lead_times) > 0, 'Argument aligned_lead_times must not be empty!'
        assert isinstance(aligned_times[0], datetime), 'Argument aligned_times should contain datetime objects!'
        assert len(aligned_times) == len(set(aligned_times)), 'Argument aligned_times has duplicates!'
        assert len(aligned_lead_times) == len(set(aligned_lead_times)), 'Argument aligned_lead_times has duplicates!'

        # Initialize a new array
        new_dimensions = [self['Data'].shape[0], self['Data'].shape[1], len(aligned_times), len(aligned_lead_times)]
        obs_aligned = np.full(new_dimensions, np.nan)

        # Find the corresponding value for all time and lead time combinations
        for time_index, time in enumerate(aligned_times):
            for lead_time_index, lead_time in enumerate(aligned_lead_times):

                query_time_index = binary_search(self['Times'], time + lead_time)

                if query_time_index != -1:
                    obs_aligned[:, :, time_index, lead_time_index] = self['Data'][:, :, query_time_index]

        return obs_aligned

    ######################
    # Overloaded Methods #
    ######################

    def __str__(self):
        msg = [
            '***** A dictionary modified for AnEn *****',
            'Dictionary tag: {}'.format(self._tag),
            summary(self),
            '********** End of the message ***********',
        ]

        if self._tag == 'Observations':
            msg.insert(2, 'Observation variables: {}'.format(self['ParameterNames']))

        return '\n'.join(msg)
